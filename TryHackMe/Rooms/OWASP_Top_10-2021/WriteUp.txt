Introduction

OWASP topic down and includes details on the vulnerabilities
1. Broken Access Control
2. Cryptographic Failures
3. Injection
4. Insecure Design
5. Security Misconfiguration
6. Vulnerable and Outdated Components
7. Identification and Authentication Failures
8. Software and Data Integrity Failures
9. Security Logging & Monitoring Failures
10. Server-Side Request Forgery (SSRF)


1. Broken Access Control

Usecase: Websites have pages that are protected from regular visitors. For example, only the site's admin user should be able to access a page to manage other users. If a website visitor can access protected pages they are not meant to see, then the access controls are broken.

Risk:
A regular visitor being able to access protected pages can lead to the following:
1. Being able to view sensitive information from other users
2. Accessing unauthorized functionality

Defnition: broken access control allows attackers to bypass authorisation, allowing them to view sensitive data or perform tasks they aren't supposed to.


Broken Access Control (IDOR Challenge)

Insecure Direct Object Reference:
IDOR or Insecure Direct Object Reference refers to an access control vulnerability where you can access resources you wouldn't ordinarily be able to see. This occurs when the programmer exposes a Direct Object Reference, which is just an identifier that refers to specific objects within the server. By object, we could mean a file, a user, a bank account in a banking application, or anything really.

Scenario: let's say we're logging into our bank account, and after correctly authenticating ourselves, we get taken to a URL like this https://bank.thm/account?id=111111. On that page, we can see all our important bank details, and a user would do whatever they need to do and move along their way, thinking nothing is wrong.
There is, however, a potentially huge problem here, anyone may be able to change the id parameter to something else like 222222, and if the site is incorrectly configured, then he would have access to someone else's bank information.

Risk:
The application exposes a direct object reference through the id parameter in the URL, which points to specific accounts. Since the application isn't checking if the logged-in user owns the referenced account, an attacker can get sensitive information from other users because of the IDOR vulnerability.

Note: direct object references aren't the problem, but rather that the application doesn't validate if the logged-in user should have access to the requested account.

Question 1: Look at other users' notes. What is the flag?
Look up the activity file for answer


2. Cryptographic Failures

A cryptographic failure refers to any vulnerability arising from the misuse (or lack of use) of cryptographic algorithms for protecting sensitive information. Web applications require cryptography to provide confidentiality for their users at many levels.

Usecase:
a secure email application:
1. When you are accessing your email account using your browser, you want to be sure that the communications between you and the server are encrypted. That way, any eavesdropper trying to capture your network packets won't be able to recover the content of your email addresses. When we encrypt the network traffic between the client and server, we usually refer to this as encrypting data in transit.
2. Since your emails are stored in some server managed by your provider, it is also desirable that the email provider can't read their client's emails. To this end, your emails might also be encrypted when stored on the servers. This is referred to as encrypting data at rest.

Risk:
Cryptographic failures often end up in web apps accidentally divulging sensitive data. This is often data directly linked to customers (e.g. names, dates of birth, financial information), but it could also be more technical information, such as usernames and passwords.

Cryptographic Failures (Supporting Material 1)

The most common way to store a large amount of data in a format easily accessible from many locations is in a database. This is perfect for something like a web application, as many users may interact with the website at any time. Database engines usually follow the Structured Query Language (SQL) syntax.
In a production environment, it is common to see databases set up on dedicated servers running a database service such as MySQL or MariaDB; however, databases can also be stored as files. "flat-file" databases, as they are stored as a single file on the computer. This is much easier than setting up an entire database server and could potentially be seen in smaller web applications.

flat-file databases are stored as a file on the disk of a computer.

Risk:
This would not be a problem for a web app, but what happens if the database is stored underneath the root directory of the website (i.e. one of the files accessible to the user connecting to the website)? Well, we can download and query it on our own machine, with full access to everything in the database. Sensitive Data Exposure, indeed!

The most common (and simplest) format of a flat-file database is an SQLite database. These can be interacted with in most programming languages and have a dedicated client for querying them on the command line. This client is called sqlite3 and is installed on many Linux distributions by default.

To access file(DB):
syntax: sqlite3 <database-name>
ex: sqlite3 example.db         

.tables command: used to view all the tables 
syntax: .tables
ex: .tables

To view table information:
syntax: PRAGMA table_info(<table_name>);
ex: PRAGMA table_info(customers);

To dump the information from the table:
syntax: SELECT * FROM <Table_name>;
ex: SELECT * FROM customers;


Cryptographic Failures (Supporting Material 2)

Crackstation: This website is extremely good at cracking weak password hashes. For more complicated hashes, we would need more sophisticated tools; 
It's worth noting that Crackstation works using a massive wordlist. If the password is not in the wordlist, then Crackstation will not be able to break the hash.


Cryptographic Failures (Challenge)

Question 2: Have a look around the web app. The developer has left themselves a note indicating that there is sensitive data in a specific directory. 
            What is the name of the mentioned directory?
Question 3: Navigate to the directory you found in question one. What file stands out as being likely to contain sensitive data?
Question 4: Use the supporting material to access the sensitive data. What is the password hash of the admin user?
Question 5: Crack the hash. What is the admin's plaintext password?
Question 6: Log in as the admin. What is the flag?
Look up the activity file.


3. Injection

Injection: Injection flaws are very common in applications today. These flaws occur because the application interprets user-controlled input as commands or parameters. Injection attacks depend on what technologies are used and how these technologies interpret the input

Some common examples include:
1. SQL Injection: This occurs when user-controlled input is passed to SQL queries. As a result, an attacker can pass in SQL queries to manipulate the outcome of such queries. This could potentially allow the attacker to access, modify and delete information in a database when this input is passed into database queries.
2. Command Injection: This occurs when user input is passed to system commands. As a result, an attacker can execute arbitrary system commands on application servers, potentially allowing them to access users' syste

Prevention techniques:
The main defence for preventing injection attacks is ensuring that user-controlled input is not interpreted as queries or commands. 
There are different ways of doing this:
1. Using an allow list: when input is sent to the server, this input is compared to a list of safe inputs or characters. If the input is marked as safe, then it is processed. Otherwise, it is rejected, and the application throws an error.
2. Stripping input: If the input contains dangerous characters, these are removed before processing.

Note: Dangerous characters or input is classified as any input that can change how the underlying data is processed. Instead of manually constructing allow lists or stripping input, various libraries exist that can perform these actions for you.


3.1. Command Injection

Command Injection occurs when server-side code (like PHP) in a web application makes a call to a function that interacts with the server's console directly. An injection web vulnerability allows an attacker to take advantage of that call to execute operating system commands arbitrarily on the server. The possibilities for the attacker from here are endless: they could list files, read their contents, run some basic commands to do some recon on the server or whatever they wanted, just as if they were sitting in front of the server and issuing commands directly into the command line.
Note: Once the attacker has a foothold on the web server, they can start the usual enumeration of your systems and look for ways to pivot around.

Code Example

Scenario: MooCorp has started developing a web-based application for cow ASCII art with customisable text. While searching for ways to implement their app, they've come across the cowsay command in Linux, which does just that! Instead of coding a whole web application and the logic required to make cows talk in ASCII, they decide to write some simple code that calls the cowsay command from the operating system's console and sends back its contents to the website.
Code:
<?php
    if (isset($_GET["mooing"])) {
        $mooing = $_GET["mooing"];
        $cow = 'default';

        if(isset($_GET["cow"]))
            $cow = $_GET["cow"];
        
        passthru("perl /usr/bin/cowsay -f $cow $mooing");
    }
?>

the above snippet does the following:
1. Checking if the parameter "mooing" is set. If it is, the variable $mooing gets what was passed into the input field.
2. Checking if the parameter "cow" is set. If it is, the variable $cow gets what was passed through the parameter.
3. The program then executes the function passthru("perl /usr/bin/cowsay -f $cow $mooing");. The passthru function simply executes a command in the operating system's console and sends the output back to the user's browser. You can see that our command is formed by concatenating the $cow and $mooing variables at the end of it. Since we can manipulate those variables, we can try injecting additional commands by using simple tricks. If you want to, you can read the docs on passthru() on PHP's website for more information on the function itself.

Exploiting Command Injection
we will take advantage of a bash feature called "inline commands" to abuse the cowsay server and execute any arbitrary command we want. Bash allows you to run commands within commands. This is useful for many reasons, but in our case, it will be used to inject a command within the cowsay server to get it executed.

Inline command working:If the console detects an inline command, it will execute it first and then use the result as the parameter for the outer command. 
To execute inline commands, you only need to enclose them in the following format $(your_command_here)

Commands usually tried to exploit:
whoami
id
ifconfig/ip addr
uname -a
ps -ef

Question 7: What strange text file is in the website's root directory?
Question 8: How many non-root/non-service/non-daemon users are there?
Question 9: What user is this app running as?
Question 10: What is the user's shell set as?
Question 11: What version of Alpine Linux is running?
Check out the activity file associated.

Research: How to classify non-root/non-service/non-daemon users in linux?
Each line in /etc/passwd looks like this:
username:x:UID:GID:comment:home_directory:shell

Key fields for classification:
1. UID (3rd field): User ID
2. Home directory (6th field): Often /home/<username> for real users
3. Shell (7th field): /bin/bash, /bin/zsh for real users; /usr/sbin/nologin or /bin/false for services/daemons

General Rules to Identify Human Users
1. Exclude root:
Root always has UID = 0.
2. Check UID range:
System/service accounts typically use UIDs < 1000 (on most distributions; on older ones, it's < 500).
Human users generally have UID ≥ 1000 (configurable via /etc/login.defs).
3. Valid login shell:
Human users: /bin/bash, /bin/zsh, /bin/sh etc.
Service/daemon accounts: /usr/sbin/nologin, /bin/false, etc.
4. Home directory:
Human users: /home/<username>
Service accounts: /var/lib/…, /srv/…, /nonexistent

Example Command to List Human Users
awk -F: '($3 >= 1000) && ($3 != 65534) && ($7 !~ /(nologin|false)/) {print $1}' /etc/passwd
Explination:
1. $3 >= 1000 → Filter UIDs ≥ 1000
2. $3 != 65534 → Exclude nobody (usually UID 65534)
3. $7 !~ /(nologin|false)/ → Exclude non-login shells


4. Insecure Design

Insecure design refers to vulnerabilities which are inherent to the application's architecture. They are not vulnerabilities regarding bad implementations or configurations, but the idea behind the whole application (or a part of it) is flawed from the start.
For example, disable the OTP validation in the development phases to quickly test the rest of the app without manually inputting a code at each login but forget to re-enable it when sending the application to production.

Insecure Password Resets: 
Scenario: Instagram allowed users to reset their forgotten passwords by sending them a 6-digit code to their mobile number via SMS for validation. If an attacker wanted to access a victim's account, he could try to brute-force the 6-digit code. As expected, this was not directly possible as Instagram had rate-limiting implemented so that after 250 attempts, the user would be blocked from trying further.
However, it was found that the rate-limiting only applied to code attempts made from the same IP. If an attacker had several different IP addresses from where to send requests, he could now try 250 codes per IP. For a 6-digit code, you have a million possible codes, so an attacker would need 1000000/250 = 4000 IPs to cover all possible codes. This may sound like an insane amount of IPs to have, but cloud services make it easy to get them at a relatively small cost, making this attack feasible.However, it was found that the rate-limiting only applied to code attempts made from the same IP. If an attacker had several different IP addresses from where to send requests, he could now try 250 codes per IP. For a 6-digit code, you have a million possible codes, so an attacker would need 1000000/250 = 4000 IPs to cover all possible codes. This may sound like an insane amount of IPs to have, but cloud services make it easy to get them at a relatively small cost, making this attack feasible.

Since insecure design vulnerabilities are introduced at such an early stage in the development process, resolving them often requires rebuilding the vulnerable part of the application from the ground up and is usually harder to do than any other simple code-related vulnerability. The best approach to avoid such vulnerabilities is to perform threat modelling at the early stages of the development lifecycle.

Question 12: What is the value of the flag in joseph's account?
Checkout the activity file.


5. Security Misconfiguration

Security Misconfigurations are distinct from the other Top 10 vulnerabilities because they occur when security could have been appropriately configured but was not.

Security misconfigurations include:
1. Poorly configured permissions on cloud services, like S3 buckets.
2. Having unnecessary features enabled, like services, pages, accounts or privileges.
3. Default accounts with unchanged passwords.
4. Error messages that are overly detailed and allow attackers to find out more about the system.
5. Not using HTTP security headers: https://owasp.org/www-project-secure-headers/.

OWASP Top 10 entry for Security Misconfiguration: https://owasp.org/Top10/A05_2021-Security_Misconfiguration/

Debugging interfaces
A common security misconfiguration concerns the exposure of debugging features in production software. Debugging features are often available in programming frameworks to allow the developers to access advanced functionality that is useful for debugging an application while it's being developed. Attackers could abuse some of those debug functionalities if somehow, the developers forgot to disable them before publishing their applications.

Breach: Patreon 2015
Issue: Werkzeug is a vital component in Python-based web applications as it provides an interface for web servers to execute the Python code. Werkzeug includes a debug console that can be accessed either via URL on /console, or it will also be presented to the user if an exception is raised by the application. In both cases, the console provides a Python console that will run any code you send to it.

Question 13: What is the database file name (the one with the .db extension) in the current directory?
Question 14: Modify the code to read the contents of the app.py file, which contains the application's source code. What is the value of the secret_flag variable in the source code?
Checkout the activity file.

Research: How would one know the misconfiguration on the application while interacting with it.


6. Vulnerable and Outdated Components

Company/entity you're pen-testing is using a program with a well-known vulnerability.
For example, let's say that a company hasn't updated their version of WordPress for a few years, and using a tool such as WPScan, you find that it's version 4.6. Some quick research will reveal that WordPress 4.6 is vulnerable to an unauthenticated remote code execution(RCE) exploit, and even better, you can find an exploit already made on Exploit-DB: https://www.exploit-db.com/exploits/41962.

Note: The situation worsens when you realise that it's really easy for this to happen. If a company misses a single update for a program they use, it could be vulnerable to any number of attacks.


Vulnerable and Outdated Components - Exploit

Our main job is to find out the information of the software and research it until we can find an exploit. 
Example: 
Let's go through that with an example web application.
What do you know? This server has the default page for the Nostromo web server. Now that we have a version number and a software name, we can use Exploit-DB to try and find an exploit for this particular version.
Lucky us, the top result happens to be an exploit script. Let's download it and try to get code execution. Running this script on its own teaches us a very important lesson.
Exploits you download from the Internet may not work the first time. It helps to understand the programming language the script is in so that, if needed, you can fix any bugs or make any modifications, as quite a few scripts on Exploit-DB expect you to make modifications.
We have RCE. Now it's important to note that most scripts will tell you what arguments you need to provide. Exploit developers will rarely make you read potentially hundreds of lines of code just to figure out how to use the script.

Note: Realistically, if it is a known vulnerability, there's probably a way to discover what version the application is running.

Research: Inner working of the exploit script.
 

7. Identification and Authentication Failures

Authentication and session management constitute core components of modern web applications. Authentication allows users to gain access to web applications by verifying their identities.
A user would enter these credentials, and the server would verify them. The server would then provide the users' browser with a session cookie if they are correct. A session cookie is needed because web servers use HTTP(S) to communicate, which is stateless. Attaching session cookies means the server will know who is sending what data. The server can then keep track of users' actions. 

If an attacker is able to find flaws in an authentication mechanism, they might successfully gain access to other users' accounts.
Some common flaws in authentication mechanisms include the following:
1. Brute force attacks: If a web application uses usernames and passwords, an attacker can try to launch brute force attacks that allow them to guess the username and passwords using multiple authentication attempts.
2. Use of weak credentials: Web applications should set strong password policies. If applications allow users to set passwords such as "password1" or common passwords, an attacker can easily guess them and access user accounts.
3. Weak Session Cookies: Session cookies are how the server keeps track of users. If session cookies contain predictable values, attackers can set their own session cookies and access users' accounts. 

There can be various mitigation for broken authentication mechanisms depending on the exact flaw:
1. To avoid password-guessing attacks, ensure the application enforces a strong password policy. 
2. To avoid brute force attacks, ensure that the application enforces an automatic lockout after a certain number of attempts. This would prevent an attacker from launching more brute-force attacks.
3. Implement Multi-Factor Authentication. If a user has multiple authentication methods, for example, using a username and password and receiving a code on their mobile device, it would be difficult for an attacker to get both the password and the code to access the account.


Identification and Authentication Failures Practical

logic flaw within the authentication mechanism:
focus on a vulnerability that happens because of a developer's mistake but is very easy to exploit, i.e. re-registration of an existing user.
Example, say there is an existing user with the name admin, and we want access to their account, so what we can do is try to re-register that username but with slight modification. We will enter " admin" without the quotes (notice the space at the start). Now when you enter that in the username field and enter other required information like email id or password and submit that data, it will register a new user, but that user will have the same right as the admin account. That new user will also be able to see all the content presented under the user admin.

Question 15: What is the flag that you found in darren's account?
Question 16: What is the flag that you found in arthur's account?


8. Software and Data Integrity Failures

What is Integrity?
we refer to the capacity we have to ascertain that a piece of data remains unmodified. Integrity is essential in cybersecurity as we care about maintaining important data free from unwanted or malicious modifications.

Note: often see a hash sent alongside the file so that you can prove that the file you downloaded kept its integrity and wasn't modified in transit. 

Software and Data Integrity Failures
This vulnerability arises from code or infrastructure that uses software or data without using any kind of integrity checks. Since no integrity verification is being done, an attacker might modify the software or data passed to the application, resulting in unexpected consequences.

There are mainly two types of vulnerabilities in this category:
1. Software Integrity Failures
2. Data Integrity Failures


Software Integrity Failures

Remote third party repo is compromised and changes are done to the library code. This code further be executed unknowingly any browser fetching the remote repo's  library.
Example: jQuery
Usage: <script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
This is a software integrity failure as your website makes no checks against the third-party library to see if it has changed. Modern browsers allow you to specify a hash along the library's URL so that the library code is executed only if the hash of the downloaded file matches the expected value. This security mechanism is called Subresource Integrity (SRI).

Note: Further know about Subresource Integrity checkout : https://www.srihash.org/

The correct way to insert the library in your HTML code would be to use SRI and include an integrity hash so that if somehow an attacker is able to modify the library, any client navigating through your website won't execute the modified version.
Usage: <script src="https://code.jquery.com/jquery-3.6.1.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>

Navigate to https://www.srihash.org/ to generate hashes for different library.

Question 17: What is the SHA-256 hash of https://code.jquery.com/jquery-1.12.4.min.js?
Checkout the activity file.


Data Integrity Failures

Web applications maintain sessions. Usually, when a user logs into an application, they will be assigned some sort of session token that will need to be saved on the browser for as long as the session lasts. This token will be repeated on each subsequent request so that the web application knows who we are. These session tokens can come in many forms but are usually assigned via cookies. Cookies are key-value pairs that a web application will store on the user's browser and that will be automatically repeated on each request to the website that issued them.

One solution to this is to use some integrity mechanism to guarantee that the cookie hasn't been altered by the user. To avoid re-inventing the wheel, we could use some token implementations that allow you to do this and deal with all of the cryptography to provide proof of integrity without you having to bother with it. One such implementation is JSON Web Tokens (JWT).

JSON Web Tokens (JWT):
JWTs are very simple tokens that allow you to store key-value pairs on a token that provides integrity as part of the token. The idea is that you can generate tokens that you can give your users with the certainty that they won't be able to alter the key-value pairs and pass the integrity check. 
The structure of a JWT token is formed of 3 parts:
1. Header:  header contains metadata indicating this is a JWT, and the signing algorithm in use is HS256
2. Payload: payload contains the key-value pairs with the data that the web application wants the client to store
3. Signature: signature is similar to a hash, taken to verify the payload's integrity.

Note: Unlike a simple hash, this signature involves the use of a secret key held by the server only, which means that if you change the payload, you won't be able to generate the matching signature unless you know the secret key.

3 parts of the token is simply plaintext encoded with base64, can be decoded using online tool: https://appdevtools.com/base64-encoder-decoder
Note: The signature contains binary data, so even if you decode it, you won't be able to make much sense of it anyways.

JWT and the None Algorithm
A data integrity failure vulnerability was present on some libraries implementing JWTs a while ago. JWT implements a signature to validate the integrity of the payload data. 
The vulnerable libraries allowed attackers to bypass the signature validation by changing the two following things in a JWT:
1. Modify the header section of the token so that the alg header would contain the value none.
2. Remove the signature part.

example, if we wanted to change the payload so that the username becomes "admin" and no signature check is done, we would have to decode the header and payload, modify them as needed, and encode them back. Notice how we removed the signature part but kept the dot at the end.

Question 18: Try logging into the application as guest. What is guest's account password?
Question 19: What is the name of the website's cookie containing a JWT token?
Question 20: What is the flag presented to the admin user?
Checkout the activity file to get ways to find the answers.


9. Security Logging and Monitoring Failures

Web applications are set up, every action performed by the user should be logged. Logging is important because, in the event of an incident, the attackers' activities can be traced. Once their actions are traced, their risk and impact can be determined. Without logging, there would be no way to tell what actions were performed by an attacker if they gain access to particular web applications.
The more significant impacts of these include:
1. Regulatory damage: if an attacker has gained access to personally identifiable user information and there is no record of this, final users are affected, and the application owners may be subject to fines or more severe actions depending on regulations.
2. Risk of further attacks: an attacker's presence may be undetected without logging. This could allow an attacker to launch further attacks against web application owners by stealing credentials, attacking infrastructure and more.

The information stored in logs should include the following:
1. HTTP status codes
2. Time Stamps
3. Usernames
4. API endpoints/page locations
5. IP addresses

Note: These logs have some sensitive information, so it's important to ensure that they are stored securely and that multiple copies of these logs are stored at different locations.

Logging is more important after a breach or incident has occurred. The ideal case is to have monitoring in place to detect any suspicious activity. The aim of detecting this suspicious activity is to either stop the attacker completely or reduce the impact they've made if their presence has been detected much later than anticipated.
Common examples of suspicious activity include:
1. Multiple unauthorised attempts for a particular action (usually authentication attempts or access to unauthorised resources, e.g. admin pages)
2. Requests from anomalous IP addresses or locations: while this can indicate that someone else is trying to access a particular user's account, it can also have a false positive rate.
3. Use of automated tools: particular automated tooling can be easily identifiable, e.g. using the value of User-Agent headers or the speed of requests. This can indicate that an attacker is using automated tooling.
4. Common payloads: in web applications, it's common for attackers to use known payloads. Detecting the use of these payloads can indicate the presence of someone conducting unauthorised/malicious testing on applications.

Question 21: What IP address is the attacker using?
Question 22: What kind of attack is being carried out?
Checkout the activity file.


10. Server-Side Request Forgery (SSRF)

Vulnerability occurs when an attacker can coerce a web application into sending requests on their behalf to arbitrary destinations while having control of the contents of the request itself. SSRF vulnerabilities often arise from implementations where our web application needs to use third-party services.

example, of a web application that uses an external API to send SMS notifications to its clients. For each email, the website needs to make a web request to the SMS provider's server to send the content of the message to be sent. Since the SMS provider charges per message, they require you to add a secret key, which they pre-assign to you, to each request you make to their API. The API key serves as an authentication token and allows the provider to know to whom to bill each message. 

SSRF can actually be used to do much more. In general, depending on the specifics of each scenario, SSRF can be used for:
1. Enumerate internal networks, including IP addresses and ports.
2. Abuse trust relationships between servers and gain access to otherwise restricted services.
3. Interact with some non-HTTP services to get remote code execution (RCE).

Question 23: Explore the website. What is the only host allowed to access the admin area?
Question 24: Check the "Download Resume" button. Where does the server parameter point to?
Question 25: Using SSRF, make the application send the request to your AttackBox instead of the secure file storage. Are there any API keys in the intercepted request?
Checkout the activity file.
Going the Extra Mile: There's a way to use SSRF to gain access to the site's admin area. Can you find it? 

